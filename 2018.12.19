1.获取日志数据进行中
  使用了 inotify 进行日志的监控，对于单台日志的动态实时获取，已经基本完成。
  #!/bin/bash

Path=/home/hdd2/syslog

/usr/bin/inotifywait -mrq --format '%w%f' -e create,modify $Path | while read line
do

    if [ -f $line ];then
        if [[ $line =~ 'heimdallrd' ]];then
            tail -1f $line
        fi
    fi
done

用 -1f ,可以做到每条日志试试监测，但是只能监测一台
因为hd日志，一次登录，每秒产生好几条，导致 -n1 获取的数据速度，和监控实时变化的速度不相匹配。

通过shell并发，可以实现多台的实时监控
Path=/home/hdd2/syslog

arr=`ls -l $Path | grep -v total | awk '{print $NF}'`
for a in $arr
do
    {
        /usr/bin/inotifywait -mrq --format '%w%f' -e create,modify $Path/$a/heimdallrd.log | while read line
        do
            if [ -f $line ];then
                if [[ $line =~ 'heimdallrd' ]];then
                    tail -1f $line
                #hostname=`tail -1f $line | awk '{print $4}'`
                #log=`tail -1f $line | awk -F 'heimdallrd' '{print $NF}'`
                #times=`date +%Y-%m-%d" "%T`
                #echo $hostname $log $times
                #curl -X POST 'els_url:9200/heimdallrd/_doc' -d {time:$times, hostname:$hostname, log:$log}
                fi
            fi
            continue
        done
        echo $line
    }&
done
wait
中间注释的问题，即为
目前获取到数据后，如何处理和推送成功与否至elastic

关键问题：如何应对 -f
已和于哥反馈，表示-f无法退出，还是有问题的。


2.cmd代码阅读
  c 语言，ASCII https://blog.csdn.net/qq_29350001/article/details/53320881，在 handle_control() 
  
  对面向过程，感觉有种似懂非懂的感觉

3.leetcode 编程题
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
     
 自己想的思路:
 1.对字符串进行 set 操作，将得到这个字符串的元素
 
 2.对元素进行排列组合得 arr
 
 3.从arr中最长组合开始遍历，判断是否在字符串中，若在，则返回。这样还能避免计算有两个最长。
 
 缺点，元素多了，排列组合n个。
 第二步耗费时间
 但 3 的时间复杂度为 O(n)
 
 class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        s1 = list(s)
        arr = list(set(s1))
        
        from itertools import combinations,permutations
        i = 1
        result = []
        while i <= len(arr):
            for k in permutaions(arr, i):
                result.append(k)
            i += 1
            
        for r in result:
            strs = ''.join(r)
            if strs in s:
                return len(r)
                
代码运行，表示找不到NameError: global name 'permutaions' is not defined
个人感觉思路应该没什么问题。就是耗时

没搞懂滑动窗口。
大概是
用hashset，存储当前子串，然后，判断这个子串的下一个字符，是否在这个子串中。在的话，从这个子串的第二个字符开始，去掉第一个字符
